<style>

@import url(//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.2/leaflet.css);
@import url(../style.css?aea6f0a);

#map {
  width: 960px;
  height: 500px;
}

svg {
  position: relative;
}

path {
  fill: #000;
  fill-opacity: .2;
  stroke: #fff;
  stroke-width: 1.5px;
}

path:hover {
  fill: brown;
  fill-opacity: .7;
}
.dot{
	fill: black;
}

</style>
<body>
	<div id = "map"></p>
</body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.2/leaflet.js"></script>
<script>

var width = 960, height = 500
var map = new L.Map("map", {center: [34.1, 68], zoom: 6})
    .addLayer(new L.TileLayer("http://{s}.tiles.mapbox.com/v3/examples.map-zr0njcqy/{z}/{x}/{y}.png"));

var svg = d3.select(map.getPanes().overlayPane).append("svg"),
    g = svg.append("g").attr("class", "leaflet-zoom-hide");

d3.csv("incidents.csv", function(data){
	var collection = {
		"type": "FeatureCollection"
		,"features": data.map(function(d){
			return {
				"type": "Feature"
				,"properties": {
					"wounded": parseInt(d.civilianwia)
					,"killed": parseInt(d.civiliankia)
				}
				,"geometry": {
					"type": "Point"
					,"coordinates" : [parseFloat(d.longitude), parseFloat(d.latitude)]
				}
			}
		})
	}

	var transform = d3.geo.transform({point: projectPoint}),
		path = d3.geo.path().projection(transform).pointRadius(3);

	var dots = g.selectAll(".dot").data(collection.features)
		.enter()
		.append("path")

	map.on("viewreset", reset);
	reset();

	// Reposition the SVG to cover the features.
	function reset() {
	// d3.selectAll()
		var bounds = path.bounds(collection), // Change bounds function to work with 
			topLeft = bounds[0],
			bottomRight = bounds[1]
			,newWidth = bottomRight[0] - topLeft[0] < width ? width : bottomRight[0] - topLeft[0]
			,newHeight = bottomRight[1] - topLeft[1] < height ? height : bottomRight[1] - topLeft[1];

		var radscale = d3.scale.sqrt()
			.domain([0, d3.sum(collection.features, function(d){return d.properties.wounded + d.properties.killed})])
			.range([1.5, Math.sqrt(newWidth * newHeight * 0.03 / Math.PI)])

		var points = collection.features.map(function(d){
			var coordinates = path.centroid(d)
			return {
				x: coordinates[0]
				,y: coordinates[1]
				,r: radscale(d.properties.wounded + d.properties.killed)
			}
		})
		var groups = g.selectAll(".group").data(pointsReduce(points), function(d){return "x:" + d.x + ",y:" + d.y})
		groups.exit().remove()
		groups.enter()
		  .append("circle")
			.attr("fill", "#b7cbfa")
			.attr("class", "group")
			.attr("stroke", "black")
			.attr("stroke-width", 2)
			.attr("r", function(d){return d.r})
			.attr("cx", function(d){return d.x})
			.attr("cy", function(d){return d.y})
			.style("fill-opacity", 0.4)
		
		dots.attr("d", path).attr("class", "dot")
			.style("fill-opacity", 1)
		svg .attr("width", newWidth)
			.attr("height", newHeight)
			.style("left", newWidth == width ? "0px" : topLeft[0] + "px")
			.style("top", newHeight == height ? "0px" : topLeft[1] + "px");
		var xTran = newWidth == width ? 0 : -topLeft[0]
			,yTran = newHeight == height ? 0 : -topLeft[1]
		
		g   .attr("transform", "translate(" + xTran + "," + yTran + ")");

		// dot.attr("d", path);
	} // end reset
	// Use Leaflet to implement a D3 geometric transformation.
	function projectPoint(x, y) {
		var point = map.latLngToLayerPoint(new L.LatLng(y, x));
		this.stream.point(point.x, point.y);
	} // end projectPoint

}) // end d3.csv

function pointsReduce(points) {
	// Takes an array of points with x-y coordinates & radii
	// Returns array without overlap
	var overlaps = []
	points.forEach(function(e,i){
		points.forEach(function(f,j){
			if (j > i) {overlaps.push({source: i, target: j, overlap: overlap(e,f)})}
		})
	})
	if (overlaps.filter(function(d){return d.overlap > 0 }).length > 0){
		overlaps.sort(function(a, b){return b.overlap - a.overlap})
		topranked = overlaps[0]
		var newlist = [combinepts(points[topranked.source], points[topranked.target])] 
		points.forEach(function(e,i,a){
			if (i != topranked.source && i != topranked.target) {
				newlist.push(e)
			}
		})
		return pointsReduce(newlist)
	}
	else {
		return points 
	}
}
function overlap(a,b){
	if (a.r < b.r){
		var small = a, large = b
	} else {
		var small = b, large = a
	}
	var origindist = Math.sqrt(Math.pow(small.y - large.y, 2) + Math.pow(small.x - large.x, 2))
	
	if (small.r + large.r <= origindist){
		return 0
	} 
	if (origindist + small.r <= large.r) {
		return Math.PI * Math.pow(small.r, 2) 
	} 
	
	var thetalarge = Math.acos((Math.pow(small.r, 2) - Math.pow(origindist, 2) - Math.pow(large.r, 2)) / (-2 * origindist * large.r))
	var thetasmall = Math.acos((Math.pow(large.r, 2) - Math.pow(origindist, 2) - Math.pow(small.r, 2)) / (-2 * origindist * small.r))
	
	if (large.r > origindist) {
		var area = Math.pow(small.r, 2) * thetasmall / 2
		area += (0.5 * Math.sin(thetalarge) * large.r * (large.r - origindist))
		area += (0.5 * Math.pow(large.r, 2) * (thetalarge - Math.sin(thetalarge)))
		area *= 2
		return area
	} else if (origindist == large.r) {
		var area = Math.pow(small.r, 2) * thetasmall / 2
		area += (0.5 * Math.pow(large.r, 2) * (thetalarge - Math.sin(thetalarge)))
		area *= 2
		return area
	} else {
		var area = Math.pow(large.r, 2) * thetalarge + Math.pow(small.r, 2) * thetasmall
		area -= (Math.pow(large.r, 2) * Math.cos(thetalarge) * Math.sin(thetalarge) + Math.pow(small.r,2) * Math.cos(thetasmall) * Math.sin(thetasmall))
		area *= 2
		return area
	}
}
function combinepts(a,b){ 
    // takes two points with x, y, r & returns one point with area equal to the sum of the first two, oriented on the segment between the origins, at a distance weighted by area
	var newarea = Math.PI * (Math.pow(a.r, 2) + Math.pow(b.r, 2))
	var newradius = Math.sqrt(newarea / Math.PI)
	var origin = a.x <= b.x ? a : b
	var target = a.x <= b.x ? b : a
	var angle = Math.atan((target.y - origin.y)/(target.x - origin.x))
	var distance = Math.sqrt(Math.pow(target.y - origin.y, 2) + Math.pow(target.x - origin.x, 2))
	var travelratio = Math.pow(target.r, 2) * Math.PI / newarea
	var newx = origin.x + distance * travelratio * Math.cos(angle)
	var newy = origin.y + distance * travelratio * Math.sin(angle)
	return {x: newx, y: newy, r: newradius}
}
function visual(build, update, id){
	// each of build and update should take an argument for data
	this.build = build(id)
	this.update = update(id)
}
</script>